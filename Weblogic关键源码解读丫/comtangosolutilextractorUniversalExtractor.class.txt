//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.tangosol.util.extractor;

import com.oracle.common.internal.util.CanonicalNames;
import com.tangosol.internal.util.extractor.TargetReflectionDescriptor;
import com.tangosol.internal.util.invoke.Lambdas;
import com.tangosol.io.ExternalizableLite;
import com.tangosol.io.pof.PofReader;
import com.tangosol.io.pof.PofWriter;
import com.tangosol.io.pof.PortableObject;
import com.tangosol.util.ClassHelper;
import com.tangosol.util.MapEvent;
import com.tangosol.util.ValueExtractor;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.NotActiveException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;
import javax.json.bind.annotation.JsonbCreator;
import javax.json.bind.annotation.JsonbProperty;

public class UniversalExtractor<T, E> extends AbstractExtractor<T, E> implements ValueExtractor<T, E>, ExternalizableLite, PortableObject {
    public static final String[] BEAN_ACCESSOR_PREFIXES;
    public static final String METHOD_SUFFIX = "()";
    @JsonbProperty("name")
    protected String m_sName;
    @JsonbProperty("params")
    protected Object[] m_aoParam;
    protected transient String m_sNameCanon;
    private transient TargetReflectionDescriptor m_cacheTarget;
    private transient boolean m_fMethod;

    public UniversalExtractor() {
        this.m_sNameCanon = null;
    }

    public UniversalExtractor(String sName) {
        this(sName, (Object[])null, 0);
    }

    public UniversalExtractor(String sName, Object[] aoParam) {
        this(sName, aoParam, 0);
    }

    @JsonbCreator
    public UniversalExtractor(@JsonbProperty("name") String sName, @JsonbProperty("params") Object[] aoParam, @JsonbProperty("target") int nTarget) {
        this.m_sNameCanon = null;
        azzert(sName != null);
        if (aoParam != null && aoParam.length > 0 && !sName.endsWith("()")) {
            throw new IllegalArgumentException("UniversalExtractor constructor: parameter sName[value:" + sName + "] must end with method suffix \"" + "()" + "\" when optional parameters provided");
        } else {
            this.m_sName = sName;
            this.m_aoParam = aoParam;
            this.m_nTarget = nTarget;
            this.init();
        }
    }

    public E extract(T oTarget) {
        if (oTarget == null) {
            return null;
        } else {
            TargetReflectionDescriptor targetPrev = this.m_cacheTarget;

            try {
                if (targetPrev != null && oTarget.getClass() == targetPrev.getTargetClass()) {
                    return targetPrev.isMap() ? ((Map)oTarget).get(this.getCanonicalName()) : targetPrev.getMethod().invoke(oTarget, this.m_aoParam);
                } else { //进入此分支，进一步查看功能
                    return this.extractComplex(oTarget);
                }
            } catch (NullPointerException var4) {
                throw new RuntimeException(this.suggestExtractFailureCause(oTarget.getClass()));
            } catch (Exception var5) {
                throw ensureRuntimeException(var5, oTarget.getClass().getName() + this + '(' + oTarget + ')');
            }
        }
    }

    public String getCanonicalName() {
        String sCName = Lambdas.getValueExtractorCanonicalName(this); //未触发
        if (sCName == null) {
            sCName = this.m_sNameCanon = CanonicalNames.computeValueExtractorCanonicalName(this.m_sName, this.m_aoParam);//this.m_sName=getDatabaseMetaData()，sCName=this.m_sNameCanon=databaseMetaData
        }

        return sCName;
    }

    public boolean equals(Object o) {
        if (super.equals(o)) {
            return true;
        } else if (this.isCanonicallyEquatable(o)) {
            return false;
        } else if (!(o instanceof UniversalExtractor)) {
            return false;
        } else {
            UniversalExtractor that = (UniversalExtractor)o;
            return this.m_nTarget == that.m_nTarget && equals(this.m_sName, that.m_sName) && equalsDeep(this.m_aoParam, that.m_aoParam);
        }
    }

    public int hashCode() {
        String sCName = this.getCanonicalName();
        return sCName == null ? this.m_sName.hashCode() : super.hashCode();
    }

    public String toString() {
        Object[] aoParam = this.m_aoParam;
        int cParams = aoParam == null ? 0 : aoParam.length;
        StringBuilder sb = new StringBuilder();
        if (this.m_nTarget == 1) {
            sb.append(".getKey()");
        }

        if (this.isPropertyExtractor()) {
            String sCName = this.getCanonicalName();
            if (sCName != null && sCName.length() > 0) {
                sb.append("." + sCName);
                return sb.toString();
            } else {
                return "";
            }
        } else {
            if (this.isMethodExtractor()) {
                sb.append('.').append(this.getMethodName()).append('(');

                for(int i = 0; i < cParams; ++i) {
                    if (i != 0) {
                        sb.append(", ");
                    }

                    sb.append(aoParam[i]);
                }

                sb.append(')');
            }

            return sb.toString();
        }
    }

    protected void init() {
        String sCName = this.getCanonicalName();
        this.m_fMethod = sCName == null || sCName.endsWith("()");
    }

    public String getMethodName() {
        int METHOD_SUFFIX_LENGTH = "()".length();
        String sCName = this.getCanonicalName();
        String sName = sCName == null ? this.m_sName : sCName;
        return this.isMethodExtractor() ? sName.substring(0, sName.length() - METHOD_SUFFIX_LENGTH) : "get" + Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);
    }

    public String getName() {
        return this.m_sName;
    }

    public String getPropertyName() {
        return this.isPropertyExtractor() ? this.getCanonicalName() : null;
    }

    public boolean isPropertyExtractor() {
        return !this.m_fMethod;
    }

    public boolean isMethodExtractor() {
        return this.m_fMethod;
    }

    public Object[] getParameters() {
        return this.m_aoParam;
    }

    protected E extractComplex(T oTarget) throws InvocationTargetException, IllegalAccessException {
        Class clzTarget = oTarget.getClass(); //反射方法获取其类指针
        Object[] aoParam = this.m_aoParam;  
        Class[] clzParam = ClassHelper.getClassArray(aoParam);  //获得对应类名
        String sCName = this.getCanonicalName(); //规范化this.m_sName中的类名
        boolean fProperty = this.isPropertyExtractor(); //是否提取详细内容，是!this.m_fMethod值
        Method method = null; 
        if (fProperty) {
            String sBeanAttribute = Character.toUpperCase(sCName.charAt(0)) + sCName.substring(1);

            for(int cchPrefix = 0; cchPrefix < BEAN_ACCESSOR_PREFIXES.length && method == null; ++cchPrefix) { //BEAN_ACCESSOR_PREFIXES=["get","is"]
                //findMethod(Class clz类指针, String sName方法名, Class[] aclzParam参数类型, boolean fStatic)
				method = ClassHelper.findMethod(clzTarget, BEAN_ACCESSOR_PREFIXES[cchPrefix] + sBeanAttribute, clzParam, false); //获得方法完整信息
            }
        } else {
            method = ClassHelper.findMethod(clzTarget, this.getMethodName(), clzParam, false);
        }

        if (method == null) {
            if (fProperty && oTarget instanceof Map) {
                this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget);
                return ((Map)oTarget).get(sCName);
            }
        } else {
            this.m_cacheTarget = new TargetReflectionDescriptor(clzTarget, method);
        }
		//反射函数，method是方法，oTarget是类实例，aoParam是方法所需的参数，此处是调用getDatabaseMetaData()方法
        return method.invoke(oTarget, aoParam);
    }

    private String suggestExtractFailureCause(Class clzTarget) {
        TargetReflectionDescriptor targetPrev = this.m_cacheTarget;
        if (targetPrev != null && targetPrev.isMap()) {
            return "Failed accessing target of class " + clzTarget.getCanonicalName() + " using property " + this.getCanonicalName();
        } else {
            String sMsg = "Missing or inaccessible method: " + clzTarget.getName() + this;
            if (MapEvent.class.isAssignableFrom(clzTarget)) {
                sMsg = sMsg + " (the object is a com.oracle.coherence.util.MapEvent, which may suggest that a raw com.oracle.coherence.util.Filter is being used to filter map events rather than a com.oracle.coherence.util.filter.MapEventFilter)";
            }

            return sMsg;
        }
    }

    public static <T, E> ValueExtractor<T, E> createExtractor(String sNames) {
        if (sNames != null && sNames.length() != 0) {
            return (ValueExtractor)(sNames.indexOf(46) < 0 ? new UniversalExtractor(sNames) : new ChainedExtractor(ChainedExtractor.createExtractors(sNames)));
        } else {
            return IdentityExtractor.INSTANCE;
        }
    }

    public void readExternal(DataInput in) throws IOException {
        this.m_sName = readUTF(in);
        int cParams = readInt(in);
        Object[] aoParam = cParams == 0 ? null : new Object[cParams];

        for(int i = 0; i < cParams; ++i) {
            aoParam[i] = readObject(in);
        }

        this.m_aoParam = aoParam;
        this.m_nTarget = readInt(in);
        this.init();
    }

    public void writeExternal(DataOutput out) throws IOException {
        String sMethod = this.m_sName;
        if (sMethod == null) {
            throw new NotActiveException("UniversalExtractor was constructed without a method name");
        } else {
            Object[] aoParam = this.m_aoParam;
            int cParams = aoParam == null ? 0 : aoParam.length;
            writeUTF(out, sMethod);
            writeInt(out, cParams);

            for(int i = 0; i < cParams; ++i) {
                writeObject(out, aoParam[i]);
            }

            writeInt(out, this.m_nTarget);
        }
    }

    public void readExternal(PofReader in) throws IOException {
        this.m_sName = in.readString(0);
        this.m_aoParam = in.readArray(1, (x$0) -> {
            return new Object[x$0];
        });
        this.m_nTarget = in.readInt(2);
        this.init();
    }

    public void writeExternal(PofWriter out) throws IOException {
        String sMethod = this.m_sName;
        if (sMethod == null) {
            throw new NotActiveException("UniversalExtractor was constructed without a method name");
        } else {
            out.writeString(0, sMethod);
            out.writeObjectArray(1, this.m_aoParam);
            out.writeInt(2, this.m_nTarget);
        }
    }

    static {
        BEAN_ACCESSOR_PREFIXES = CanonicalNames.VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES;
    }
}
