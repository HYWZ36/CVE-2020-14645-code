//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package com.tangosol.util;

import com.tangosol.run.xml.XmlElement;
import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.AbstractMap.SimpleEntry;
import java.util.Map.Entry;

public abstract class ClassHelper {
    private static Hashtable tblPrimitives = new Hashtable(10, 1.0F);
    public static final Class[] VOID_PARAMS;
    public static final Object[] VOID;

    public ClassHelper() {
    }

    public static boolean isInstanceOf(Object obj, String sClz) {
        try {
            return isInstanceOf(obj, Class.forName(sClz));
        } catch (Exception var3) {
            return false;
        }
    }

    public static boolean isInstanceOf(Object obj, Class clz) {
        return clz.isAssignableFrom(obj.getClass());
    }

    public static String getPackageName(Class clz) {
        String sFullClass = clz.getName();
        int ofDotClass = sFullClass.lastIndexOf(46);
        return ofDotClass < 0 ? "" : sFullClass.substring(0, ofDotClass + 1);
    }

    public static String getPackageName(String sName) {
        int ofLastDot = sName.lastIndexOf(46);
        if (ofLastDot < 0) {
            return "";
        } else if (ofLastDot == sName.length() - 1) {
            return sName;
        } else {
            return ofLastDot > 0 ? sName.substring(0, ofLastDot + 1) : sName + '.';
        }
    }

    public static String getSimpleName(Class clz) {
        String sFullClass = clz.getName();
        int ofDotClass = sFullClass.lastIndexOf(46);
        if (ofDotClass < 0) {
            return sFullClass;
        } else {
            String sName = sFullClass.substring(ofDotClass + 1);
            int ofInnerClass = sName.lastIndexOf(36);
            return ofInnerClass < 0 ? sName : sName.substring(ofInnerClass + 1);
        }
    }

    public static String getSimpleName(String sName) {
        int ofLastDot = sName.lastIndexOf(46);
        if (ofLastDot < 0) {
            return sName;
        } else if (ofLastDot == sName.length() - 1) {
            return "";
        } else {
            return ofLastDot > 0 ? sName.substring(ofLastDot + 1) : "";
        }
    }

    public static String getQualifiedName(String pkg, String sName) {
        if (pkg.length() == 0) {
            return sName;
        } else {
            if (pkg.charAt(0) == '.') {
                pkg = pkg.substring(1);
            }

            return pkg.charAt(pkg.length() - 1) == '.' ? pkg + sName : pkg + '.' + sName;
        }
    }

    public static String getCompositePackage(String pkg1, String pkg2) {
        String sComposite;
        if (pkg1.length() == 0) {
            sComposite = pkg2;
        } else if (pkg2.length() == 0) {
            sComposite = pkg1;
        } else if (pkg2.charAt(0) != '.') {
            sComposite = pkg2;
        } else if (pkg1.charAt(pkg1.length() - 1) == '.') {
            sComposite = pkg1 + pkg2.substring(1);
        } else {
            sComposite = pkg1 + pkg2;
        }

        if (sComposite.length() > 0 && sComposite.charAt(sComposite.length() - 1) != '.') {
            sComposite = sComposite + '.';
        }

        return sComposite;
    }

    public static String getCompositeName(Class clz, String sName) {
        return getCompositeName(clz.getName(), sName);
    }

    public static String getCompositeName(String sName1, String sName2) {
        String sPkg = getCompositePackage(getPackageName(sName1), getPackageName(sName2));
        String sClass = getSimpleName(sName2);
        if (sClass.length() == 0) {
            sClass = getSimpleName(sName1);
        }

        return getQualifiedName(sPkg, sClass);
    }

    public static String getDerivedName(Class clz, String sPrefix) {
        return getDerivedName(clz.getName(), sPrefix);
    }

    public static String getDerivedName(String sName, String sPrefix) {
        String sPkg = getCompositePackage(getPackageName(sName), getPackageName(sPrefix));
        sPrefix = getSimpleName(sPrefix);
        String sSuffix = getSimpleName(sName);
        return getQualifiedName(sPkg, sPrefix + sSuffix);
    }

    public static boolean isPartialNameLegal(String sName) {
        if (sName != null && sName.length() != 0) {
            int ofStart = 0;
            int ofEnd = sName.length();
            if (sName.charAt(ofStart) == '.') {
                ++ofStart;
            }

            if (ofEnd > 1 && sName.charAt(ofEnd - 1) == '.') {
                --ofEnd;
            }

            return isQualifiedNameLegal(sName.substring(ofStart, ofEnd));
        } else {
            return false;
        }
    }

    public static boolean isSimpleNameLegal(String sName) {
        char[] ach = sName.toCharArray();
        int cch = ach.length;
        if (cch >= 1 && Character.isJavaIdentifierStart(ach[0])) {
            for(int i = 1; i < cch; ++i) {
                if (!Character.isJavaIdentifierPart(ach[i])) {
                    return false;
                }
            }

            return true;
        } else {
            return false;
        }
    }

    public static boolean isQualifiedNameLegal(String sName) {
        int cch = sName.length();
        if (cch < 1) {
            return false;
        } else {
            int ofEnd;
            for(int ofStart = 0; ofStart < cch; ofStart = ofEnd + 1) {
                ofEnd = sName.indexOf(46, ofStart);
                if (ofEnd == cch - 1) {
                    return false;
                }

                if (ofEnd < 0) {
                    ofEnd = cch;
                }

                if (!isSimpleNameLegal(sName.substring(ofStart, ofEnd))) {
                    return false;
                }
            }

            return true;
        }
    }
	// 根据参数集获得对应的类【组成集合数组】
    public static Class[] getClassArray(Object[] aoParam) {
        if (aoParam != null) {
            int cParams = aoParam.length;
            if (cParams > 0) {
                Class[] aClass = new Class[cParams];

                for(int i = 0; i < cParams; ++i) {
                    Object oParam = aoParam[i];
                    if (oParam != null) {
                        aClass[i] = oParam.getClass();
                    }
                }

                return aClass;
            }
        }

        return VOID_PARAMS;
    }

    public static Class[] unwrap(Class[] aClasses) {
        for(int i = 0; i < aClasses.length; ++i) {
            Class<?> clz = aClasses[i];
            if (clz == null) {
                aClasses[i] = Object.class;
            }

            if (clz == Boolean.class) {
                aClasses[i] = Integer.TYPE;
            }

            if (clz == Byte.class) {
                aClasses[i] = Byte.TYPE;
            }

            if (clz == Character.class) {
                aClasses[i] = Character.TYPE;
            }

            if (clz == Short.class) {
                aClasses[i] = Short.TYPE;
            }

            if (clz == Integer.class) {
                aClasses[i] = Integer.TYPE;
            }

            if (clz == Long.class) {
                aClasses[i] = Long.TYPE;
            }

            if (clz == Float.class) {
                aClasses[i] = Float.TYPE;
            }

            if (clz == Double.class) {
                aClasses[i] = Double.TYPE;
            }
        }

        return aClasses;
    }

    public static Resources getPackageResources(String sClass) throws MissingResourceException {
        return (Resources)ResourceBundle.getBundle(getCompositeName(sClass, "PackageResources"));
    }

    public static Resources getPackageResources(Class clz) throws MissingResourceException {
        return getResources(clz, "PackageResources");
    }

    public static Resources getResources(Class clz, String sName) throws MissingResourceException {
        return (Resources)ResourceBundle.getBundle(getCompositeName(clz, sName));
    }

    public static Object newInstance(Class clz, Object[] aoParam) throws InstantiationException, InvocationTargetException {
        if (clz == null) {
            throw new InstantiationException("Required class object is null");
        } else {
            if (aoParam == null) {
                aoParam = VOID;
            }

            int cParams = aoParam.length;
            if (cParams == 0) {
                try {
                    return clz.newInstance();
                } catch (InstantiationException var14) {
                    if (var14.getMessage() == null) {
                        throw new InstantiationException(clz.getName());
                    } else {
                        throw var14;
                    }
                } catch (IllegalAccessException var15) {
                    throw new InstantiationException(var15.toString());
                }
            } else {
                Class[] aclzParam = cParams == 0 ? VOID_PARAMS : new Class[cParams];
                boolean fExactMatch = true;

                for(int i = 0; i < cParams; ++i) {
                    if (aoParam[i] == null) {
                        fExactMatch = false;
                    } else {
                        aclzParam[i] = aoParam[i].getClass();
                    }
                }

                Constructor constrMatch = null;
                if (fExactMatch) {
                    try {
                        constrMatch = clz.getConstructor(aclzParam);
                    } catch (Exception var13) {
                    }
                }

                int i;
                if (constrMatch == null) {
                    Constructor[] aconstr = clz.getConstructors();
                    i = aconstr.length;

                    for(int iconstr = 0; iconstr < i; ++iconstr) {
                        Constructor constr = aconstr[iconstr];
                        Class[] aclzActual = constr.getParameterTypes();
                        if (aclzActual.length == cParams) {
                            boolean fMatch = true;

                            for(int i = 0; i < cParams; ++i) {
                                if (aoParam[i] == null) {
                                    fMatch = !aclzActual[i].isPrimitive();
                                } else if (aclzActual[i].isPrimitive()) {
                                    fMatch = aclzActual[i] == (Class)tblPrimitives.get(aclzParam[i]);
                                } else {
                                    fMatch = aclzActual[i].isAssignableFrom(aclzParam[i]);
                                }

                                if (!fMatch) {
                                    break;
                                }
                            }

                            if (fMatch) {
                                constrMatch = constr;
                                break;
                            }
                        }
                    }
                }

                if (constrMatch != null) {
                    try {
                        return constrMatch.newInstance(aoParam);
                    } catch (InstantiationException var16) {
                        if (var16.getMessage() == null) {
                            throw new InstantiationException(clz.getName());
                        } else {
                            throw var16;
                        }
                    } catch (IllegalAccessException var17) {
                        throw new InstantiationException(var17.toString());
                    } catch (SecurityException var18) {
                        throw new InstantiationException(var18.toString());
                    }
                } else {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Could not find a constructor for ");
                    sb.append(clz.getName());
                    sb.append("(");

                    for(i = 0; i < cParams; ++i) {
                        if (i > 0) {
                            sb.append(", ");
                        }

                        sb.append(aoParam[i] == null ? "null" : aoParam[i].getClass().getName());
                    }

                    sb.append(")");
                    throw new InstantiationException(sb.toString());
                }
            }
        }
    }

    public static Object invokeStatic(Class clz, String sName, Object[] aoParam) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        return invoke(clz, (Object)null, sName, aoParam);
    }

    public static Object invoke(Object obj, String sName, Object[] aoParam) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        return invoke(obj.getClass(), obj, sName, aoParam);
    }

    public static Object invoke(Class clz, Object obj, String sName, Object[] aoParam) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        if (aoParam == null) {
            aoParam = VOID;
        }

        int cParams = aoParam.length;
        Class[] aclzParam = cParams == 0 ? VOID_PARAMS : new Class[cParams];

        for(int i = 0; i < cParams; ++i) {
            Object oParam = aoParam[i];
            if (oParam != null) {
                aclzParam[i] = oParam.getClass();
            }
        }

        IllegalAccessException iae = null;
        boolean fStatic = obj == null;
        Method method = findMethod(clz, sName, aclzParam, fStatic);

        while(method != null) {
            try {
                return method.invoke(obj, aoParam);
            } catch (IllegalAccessException var14) {
                if (iae == null) {
                    iae = var14;
                }

                Class[] aclzIface = clz.getInterfaces();
                int i = 0;

                for(int c = aclzIface.length; i < c; ++i) {
                    method = findMethod(aclzIface[i], sName, aclzParam, fStatic);
                    if (method != null) {
                        try {
                            return method.invoke(obj, aoParam);
                        } catch (IllegalAccessException var13) {
                        }
                    }
                }

                clz = clz.getSuperclass();
                if (clz == null) {
                    throw iae;
                }

                method = findMethod(clz, sName, aclzParam, fStatic);
            }
        }

        if (iae == null) {
            throw new NoSuchMethodException(clz.getName() + '.' + sName);
        } else {
            throw iae;
        }
    }
	// 查询符合要求的方法
    public static Method findMethod(Class clz, String sName, Class[] aclzParam, boolean fStatic) {
        if (aclzParam == null) {
            aclzParam = VOID_PARAMS;
        }

        int cParams = aclzParam.length;
        boolean fExactMatch = true;

        for(int i = 0; i < cParams; ++i) {
            if (aclzParam[i] == null) {
                fExactMatch = false;
                break;
            }
        }

        if (fExactMatch && !fStatic) {
            try {
                return clz.getMethod(sName, aclzParam);  //获得此方法的完整系列信息
            } catch (NoSuchMethodException var15) {
            }
        }

        Method[] aMethod = clz.getMethods();
        int cMethods = aMethod.length;

        label67:
        for(int iMethod = 0; iMethod < cMethods; ++iMethod) {
            Method method = aMethod[iMethod];
            if (method.getName().equals(sName) && Modifier.isStatic(method.getModifiers()) == fStatic) {
                Class[] aclzActual = method.getParameterTypes();
                if (aclzActual.length == cParams) {
                    for(int i = 0; i < cParams; ++i) {
                        Class clzParam = aclzParam[i];
                        Class clzActual = aclzActual[i];
                        boolean fMatch;
                        if (clzParam == null) {
                            fMatch = !clzActual.isPrimitive();
                        } else if (clzActual.isPrimitive()) {
                            fMatch = clzActual == tblPrimitives.get(clzParam);
                        } else {
                            fMatch = clzActual.isAssignableFrom(clzParam);
                        }

                        if (!fMatch) {
                            continue label67;
                        }
                    }

                    return method;
                }
            }
        }

        return null;
    }

    public static Class<?> getComponentType(Type type) {
        if (type == null) {
            return null;
        } else if (type instanceof Class) {
            Class<?> clz = (Class)type;
            if (clz.isArray()) {
                return clz.getComponentType();
            } else {
                return Collection.class.isAssignableFrom(clz) ? Object.class : null;
            }
        } else if (type instanceof GenericArrayType) {
            return getClass(((GenericArrayType)type).getGenericComponentType());
        } else if (type instanceof ParameterizedType) {
            ParameterizedType typeParameterized = (ParameterizedType)type;
            Type typeRaw = typeParameterized.getRawType();
            return typeRaw instanceof Class && Collection.class.isAssignableFrom((Class)typeRaw) ? getClass(typeParameterized.getActualTypeArguments()[0]) : null;
        } else {
            return null;
        }
    }

    public static Class<?> getClass(Type type) {
        if (type == null) {
            return Object.class;
        } else if (type instanceof Class) {
            return (Class)type;
        } else if (type instanceof ParameterizedType) {
            return getClass(((ParameterizedType)type).getRawType());
        } else if (!(type instanceof WildcardType) && !(type instanceof TypeVariable)) {
            return type instanceof GenericArrayType ? Object[].class : Object.class;
        } else {
            return Object.class;
        }
    }

    public static Map<String, Type[]> getReifiedTypes(Class<?> clz, Class<?> clzDefiningType) {
        if (clz == null) {
            throw new IllegalArgumentException("Class must be provided.");
        } else if (clzDefiningType == null) {
            throw new IllegalArgumentException("Class that defines the types to reify must be provided.");
        } else if (!clzDefiningType.isAssignableFrom(clz)) {
            throw new IllegalArgumentException(clz.getName() + " is not assignable to: " + clzDefiningType);
        } else {
            Class<?> clzInspect = clz;
            Map<String, Type[]> mapTypes = new LinkedHashMap();
            LinkedList<Entry<Class<?>, Type>> listHier = new LinkedList();
            TypeVariable<? extends Class<?>>[] aIfaceTypes = clzDefiningType.getTypeParameters();
            Type typeRoot = null;

            int c;
            Type typeSuper;
            int c;
            for(Type typeCurr = clz.getGenericSuperclass(); clzInspect != null && typeRoot == null; typeCurr = clzInspect.getGenericSuperclass()) {
                Entry<Class<?>, Type> entryHier = new SimpleEntry(clzInspect, typeCurr);
                listHier.add(entryHier);
                if (clzInspect.getSuperclass() == clzDefiningType) {
                    typeRoot = typeCurr;
                } else {
                    Type[] var9 = clzInspect.getGenericInterfaces();
                    c = var9.length;

                    for(int var11 = 0; var11 < c; ++var11) {
                        typeSuper = var9[var11];
                        Type typeRaw = typeSuper instanceof Class ? typeSuper : (typeSuper instanceof ParameterizedType ? ((ParameterizedType)typeSuper).getRawType() : null);
                        if (typeRaw == clzDefiningType) {
                            typeRoot = typeSuper;
                            entryHier.setValue(typeSuper);
                            break;
                        }

                        if (typeRaw instanceof Class && clzDefiningType.isAssignableFrom((Class)typeRaw)) {
                            Class<?> clzCurIface = (Class)typeRaw;
                            entryHier.setValue(typeSuper);

                            Class[] aclzIfaces;
                            while(clzCurIface != clzDefiningType && (aclzIfaces = clzCurIface.getInterfaces()).length > 0) {
                                int i = 0;

                                for(c = aclzIfaces.length; i < c; ++i) {
                                    if (clzDefiningType.isAssignableFrom(aclzIfaces[i])) {
                                        listHier.add(new SimpleEntry(clzCurIface, clzCurIface.getGenericInterfaces()[i]));
                                        clzCurIface = aclzIfaces[i];
                                        break;
                                    }
                                }
                            }

                            typeRoot = (Type)((Entry)listHier.getLast()).getValue();
                        }
                    }
                }

                clzInspect = clzInspect.getSuperclass();
            }

            clzInspect = getClass((Type)((Entry)listHier.removeLast()).getKey());
            int i;
            if (typeRoot instanceof Class) {
                TypeVariable[] var24 = aIfaceTypes;
                int var26 = aIfaceTypes.length;

                for(i = 0; i < var26; ++i) {
                    TypeVariable<? extends Class<?>> typeVarIface = var24[i];
                    mapTypes.put(typeVarIface.getName(), typeVarIface.getBounds());
                }
            } else if (typeRoot instanceof ParameterizedType) {
                Type[] aTypes = ((ParameterizedType)typeRoot).getActualTypeArguments();
                Map<Integer, Entry<String, Type[]>> mapGenericTypes = new HashMap();
                i = 0;

                for(c = aTypes.length; i < c; ++i) {
                    Type typeArg = aTypes[i];
                    String sOrigTypeName = aIfaceTypes[i].getName();
                    if (!(typeArg instanceof Class) && !(typeArg instanceof ParameterizedType)) {
                        if (typeArg instanceof TypeVariable) {
                            TypeVariable typeVar = (TypeVariable)typeArg;
                            String sTypeName = typeVar.getName();
                            int iTypePos = 0;
                            TypeVariable[] var43 = clzInspect.getTypeParameters();
                            c = var43.length;

                            for(int var18 = 0; var18 < c; ++var18) {
                                TypeVariable<? extends Class<?>> typeVarClz = var43[var18];
                                if (sTypeName.equals(typeVarClz.getName())) {
                                    if (clzInspect == clz) {
                                        mapTypes.put(sOrigTypeName, typeVar.getBounds());
                                    } else {
                                        mapGenericTypes.put(iTypePos, new SimpleEntry(sOrigTypeName, typeVar.getBounds()));
                                    }
                                    break;
                                }

                                ++iTypePos;
                            }
                        }
                    } else {
                        mapTypes.put(sOrigTypeName, new Type[]{typeArg});
                    }
                }

                Iterator iterClzHier = listHier.descendingIterator();

                while(true) {
                    while(!mapGenericTypes.isEmpty() && iterClzHier.hasNext()) {
                        Entry<Class<?>, Type> entryHier = (Entry)iterClzHier.next();
                        Class<?> clzCurr = (Class)entryHier.getKey();
                        typeSuper = (Type)entryHier.getValue();
                        if (typeSuper instanceof Class) {
                            Iterator var37 = mapGenericTypes.values().iterator();

                            while(var37.hasNext()) {
                                Entry<String, Type[]> entry = (Entry)var37.next();
                                mapTypes.put(entry.getKey(), entry.getValue());
                            }

                            mapGenericTypes.clear();
                        } else if (typeSuper instanceof ParameterizedType) {
                            Map<Integer, Entry<String, Type[]>> mapRemaining = new HashMap();
                            Iterator var39 = mapGenericTypes.entrySet().iterator();

                            while(true) {
                                while(var39.hasNext()) {
                                    Entry<Integer, Entry<String, Type[]>> entryGeneric = (Entry)var39.next();
                                    Entry<String, Type[]> entryGenValue = (Entry)entryGeneric.getValue();
                                    Type typeGeneric = ((ParameterizedType)typeSuper).getActualTypeArguments()[(Integer)entryGeneric.getKey()];
                                    if (typeGeneric instanceof Class) {
                                        mapTypes.put(entryGenValue.getKey(), new Type[]{typeGeneric});
                                    } else if (typeGeneric instanceof TypeVariable) {
                                        String sGenTypeName = ((TypeVariable)typeGeneric).getName();
                                        int iTypePos = 0;
                                        TypeVariable[] var20 = clzCurr.getTypeParameters();
                                        int var21 = var20.length;

                                        for(int var22 = 0; var22 < var21; ++var22) {
                                            TypeVariable<? extends Class<?>> typeVarClz = var20[var22];
                                            if (sGenTypeName.equals(typeVarClz.getName())) {
                                                if (iterClzHier.hasNext()) {
                                                    entryGenValue.setValue(typeVarClz.getBounds());
                                                    mapRemaining.put(iTypePos, entryGenValue);
                                                } else {
                                                    mapTypes.put(((Entry)entryGeneric.getValue()).getKey(), typeVarClz.getBounds());
                                                }
                                                break;
                                            }

                                            ++iTypePos;
                                        }
                                    }
                                }

                                mapGenericTypes = mapRemaining;
                                break;
                            }
                        }
                    }

                    return mapTypes;
                }
            }

            return mapTypes;
        }
    }

    public static String getFullyQualifiedClassNameOf(String sAbbreviatedClassName) {
        if (sAbbreviatedClassName == null) {
            return null;
        } else {
            String sType = sAbbreviatedClassName.trim();
            if (sType.equalsIgnoreCase("string")) {
                return String.class.getName();
            } else if (sType.equalsIgnoreCase("boolean")) {
                return Boolean.class.getName();
            } else if (sType.equalsIgnoreCase("int")) {
                return Integer.class.getName();
            } else if (sType.equalsIgnoreCase("long")) {
                return Long.class.getName();
            } else if (sType.equalsIgnoreCase("double")) {
                return Double.class.getName();
            } else if (sType.equalsIgnoreCase("decimal")) {
                return BigDecimal.class.getName();
            } else if (sType.equalsIgnoreCase("file")) {
                return File.class.getName();
            } else if (sType.equalsIgnoreCase("date")) {
                return Date.class.getName();
            } else if (sType.equalsIgnoreCase("time")) {
                return Time.class.getName();
            } else if (sType.equalsIgnoreCase("datetime")) {
                return Timestamp.class.getName();
            } else if (sType.equalsIgnoreCase("xml")) {
                return XmlElement.class.getName();
            } else {
                return sType.equalsIgnoreCase("classloader") ? ClassLoader.class.getName() : sType.trim();
            }
        }
    }

    static {
        tblPrimitives.put(Boolean.class, Boolean.TYPE);
        tblPrimitives.put(Character.class, Character.TYPE);
        tblPrimitives.put(Byte.class, Byte.TYPE);
        tblPrimitives.put(Short.class, Short.TYPE);
        tblPrimitives.put(Integer.class, Integer.TYPE);
        tblPrimitives.put(Long.class, Long.TYPE);
        tblPrimitives.put(Float.class, Float.TYPE);
        tblPrimitives.put(Double.class, Double.TYPE);
        tblPrimitives.put(Void.class, Void.TYPE);
        VOID_PARAMS = new Class[0];
        VOID = new Object[0];
    }
}
